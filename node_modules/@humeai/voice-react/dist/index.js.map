{"version":3,"sources":["../src/index.ts","../src/lib/useMicrophone.ts","../src/lib/generateEmptyFft.ts","../src/lib/useSoundPlayer.ts","../src/lib/convertFrequencyScale.ts","../src/lib/useVoiceClient.ts","../src/lib/VoiceProvider.tsx","../src/lib/noop.ts","../src/lib/useCallDuration.ts","../src/lib/useEncoding.ts","../src/lib/useMessages.ts","../src/utils/index.ts","../src/lib/useToolStatus.ts","../src/lib/errors.ts","../src/lib/messages.ts","../src/lib/audio-message.ts","../src/models/audio.ts","../src/models/llm.ts","../src/models/messages.ts","../src/models/ttsService.ts"],"sourcesContent":["export * from './lib/connection-message';\nexport * from './lib/useMicrophone';\nexport * from './lib/useSoundPlayer';\nexport * from './lib/useVoiceClient';\nexport * from './lib/VoiceProvider';\nexport * from './lib/errors';\nexport * from './lib/messages';\nexport * from './models/audio';\nexport * from './models/llm';\nexport * from './models/messages';\nexport * from './models/ttsService';\n\nexport type { SocketConfig } from './lib/useVoiceClient';\n","// cspell:ignore dataavailable\nimport type { MimeType } from 'hume';\nimport { getBrowserSupportedMimeType } from 'hume';\nimport Meyda from 'meyda';\nimport type { MeydaFeaturesObject } from 'meyda';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport type { MutableRefObject } from 'react';\n\nimport { generateEmptyFft } from './generateEmptyFft';\n\nexport type MicrophoneProps = {\n  streamRef: MutableRefObject<MediaStream | null>;\n  onAudioCaptured: (b: ArrayBuffer) => void;\n  onStartRecording?: () => void;\n  onStopRecording?: () => void;\n  onError: (message: string) => void;\n};\n\nexport const useMicrophone = (props: MicrophoneProps) => {\n  const { streamRef, onAudioCaptured, onError } = props;\n  const [isMuted, setIsMuted] = useState(false);\n  const isMutedRef = useRef(isMuted);\n\n  const [fft, setFft] = useState<number[]>(generateEmptyFft());\n  const currentAnalyzer = useRef<Meyda.MeydaAnalyzer | null>(null);\n  const mimeTypeRef = useRef<MimeType | null>(null);\n\n  const audioContext = useRef<AudioContext | null>(null);\n\n  const recorder = useRef<MediaRecorder | null>(null);\n\n  const sendAudio = useRef(onAudioCaptured);\n  sendAudio.current = onAudioCaptured;\n\n  const dataHandler = useCallback((event: BlobEvent) => {\n    const blob = event.data;\n\n    blob\n      .arrayBuffer()\n      .then((buffer) => {\n        if (buffer.byteLength > 0) {\n          sendAudio.current?.(buffer);\n        }\n      })\n      .catch((err) => {\n        console.log(err);\n      });\n  }, []);\n\n  const start = useCallback(() => {\n    const stream = streamRef.current;\n    if (!stream) {\n      throw new Error('No stream connected');\n    }\n\n    const context = new AudioContext();\n    audioContext.current = context;\n    const input = context.createMediaStreamSource(stream);\n\n    try {\n      currentAnalyzer.current = Meyda.createMeydaAnalyzer({\n        audioContext: context,\n        source: input,\n        featureExtractors: ['loudness'],\n        callback: (features: MeydaFeaturesObject) => {\n          const newFft = features.loudness.specific || [];\n          setFft(() => Array.from(newFft));\n        },\n      });\n\n      currentAnalyzer.current.start();\n    } catch (e: unknown) {\n      const message = e instanceof Error ? e.message : 'Unknown error';\n      console.error(`Failed to start mic analyzer: ${message}`);\n    }\n    const mimeType = mimeTypeRef.current;\n    if (!mimeType) {\n      throw new Error('No MimeType specified');\n    }\n\n    recorder.current = new MediaRecorder(stream, {\n      mimeType,\n    });\n    recorder.current.addEventListener('dataavailable', dataHandler);\n    recorder.current.start(100);\n  }, [dataHandler, streamRef, mimeTypeRef]);\n\n  const stop = useCallback(() => {\n    try {\n      if (currentAnalyzer.current) {\n        currentAnalyzer.current.stop();\n        currentAnalyzer.current = null;\n      }\n\n      if (audioContext.current) {\n        void audioContext.current\n          .close()\n          .then(() => {\n            audioContext.current = null;\n          })\n          .catch(() => {\n            // .close() rejects if the audio context is already closed.\n            // Therefore, we just need to catch the error, but we don't need to\n            // do anything with it.\n            return null;\n          });\n      }\n\n      recorder.current?.stop();\n      recorder.current?.removeEventListener('dataavailable', dataHandler);\n      recorder.current = null;\n      streamRef.current?.getTracks().forEach((track) => track.stop());\n\n      setIsMuted(false);\n    } catch (e) {\n      const message = e instanceof Error ? e.message : 'Unknown error';\n      onError(`Error stopping microphone: ${message}`);\n      console.log(e);\n      void true;\n    }\n  }, [dataHandler, onError, streamRef]);\n\n  const mute = useCallback(() => {\n    if (currentAnalyzer.current) {\n      currentAnalyzer.current.stop();\n      setFft(generateEmptyFft());\n    }\n\n    streamRef.current?.getTracks().forEach((track) => {\n      track.enabled = false;\n    });\n\n    isMutedRef.current = true;\n    setIsMuted(true);\n  }, [streamRef]);\n\n  const unmute = useCallback(() => {\n    if (currentAnalyzer.current) {\n      currentAnalyzer.current.start();\n    }\n\n    streamRef.current?.getTracks().forEach((track) => {\n      track.enabled = true;\n    });\n\n    isMutedRef.current = false;\n    setIsMuted(false);\n  }, [streamRef]);\n\n  useEffect(() => {\n    return () => {\n      try {\n        recorder.current?.stop();\n        recorder.current?.removeEventListener('dataavailable', dataHandler);\n\n        if (currentAnalyzer.current) {\n          currentAnalyzer.current.stop();\n          currentAnalyzer.current = null;\n        }\n\n        streamRef.current?.getTracks().forEach((track) => track.stop());\n        streamRef.current = null;\n      } catch (e) {\n        console.log(e);\n        void true;\n      }\n    };\n  }, [dataHandler, streamRef]);\n\n  useEffect(() => {\n    const mimeTypeResult = getBrowserSupportedMimeType();\n    if (mimeTypeResult.success) {\n      mimeTypeRef.current = mimeTypeResult.mimeType;\n    } else {\n      onError(mimeTypeResult.error.message);\n    }\n  }, [onError]);\n\n  return {\n    start,\n    stop,\n    mute,\n    unmute,\n    isMuted,\n    fft,\n  };\n};\n","export function generateEmptyFft(): number[] {\n  return Array.from({ length: 24 }).map(() => 0);\n}\n","import { convertBase64ToBlob } from 'hume';\nimport { useCallback, useRef, useState } from 'react';\n\nimport { convertLinearFrequenciesToBark } from './convertFrequencyScale';\nimport { generateEmptyFft } from './generateEmptyFft';\nimport type { AudioOutputMessage } from '../models/messages';\n\nexport const useSoundPlayer = (props: {\n  onError: (message: string) => void;\n  onPlayAudio: (id: string) => void;\n  onStopAudio: (id: string) => void;\n}) => {\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isAudioMuted, setIsAudioMuted] = useState(false);\n  const [fft, setFft] = useState<number[]>(generateEmptyFft());\n\n  const audioContext = useRef<AudioContext | null>(null);\n  const analyserNode = useRef<AnalyserNode | null>(null);\n  const gainNode = useRef<GainNode | null>(null);\n  const isInitialized = useRef(false);\n\n  const clipQueue = useRef<\n    Array<{\n      id: string;\n      buffer: AudioBuffer;\n    }>\n  >([]);\n  const [queueLength, setQueueLength] = useState(0);\n\n  const isProcessing = useRef(false);\n  const currentlyPlayingAudioBuffer = useRef<AudioBufferSourceNode | null>(\n    null,\n  );\n  const frequencyDataIntervalId = useRef<number | null>(null);\n\n  const onPlayAudio = useRef<typeof props.onPlayAudio>(props.onPlayAudio);\n  onPlayAudio.current = props.onPlayAudio;\n\n  const onStopAudio = useRef<typeof props.onStopAudio>(props.onStopAudio);\n  onStopAudio.current = props.onStopAudio;\n\n  const onError = useRef<typeof props.onError>(props.onError);\n  onError.current = props.onError;\n\n  const playNextClip = useCallback(() => {\n    if (analyserNode.current === null || audioContext.current === null) {\n      onError.current('Audio environment is not initialized');\n      return;\n    }\n\n    if (clipQueue.current.length === 0 || isProcessing.current) {\n      setQueueLength(0);\n      return;\n    }\n\n    const nextClip = clipQueue.current.shift();\n    setQueueLength(clipQueue.current.length);\n\n    if (!nextClip) return;\n\n    isProcessing.current = true;\n    setIsPlaying(true);\n\n    // Use AudioBufferSourceNode for audio playback.\n    // Safari suffered a truncation issue using HTML5 audio playback\n    const bufferSource = audioContext.current.createBufferSource();\n\n    bufferSource.buffer = nextClip.buffer;\n\n    bufferSource.connect(analyserNode.current);\n\n    currentlyPlayingAudioBuffer.current = bufferSource;\n\n    const updateFrequencyData = () => {\n      try {\n        const bufferSampleRate = bufferSource.buffer?.sampleRate;\n\n        if (!analyserNode.current || typeof bufferSampleRate === 'undefined')\n          return;\n\n        const dataArray = new Uint8Array(\n          analyserNode.current.frequencyBinCount,\n        ); // frequencyBinCount is 1/2 of fftSize\n        analyserNode.current.getByteFrequencyData(dataArray); // Using getByteFrequencyData for performance\n\n        const barkFrequencies = convertLinearFrequenciesToBark(\n          dataArray,\n          bufferSampleRate,\n        );\n        setFft(() => barkFrequencies);\n      } catch (e) {\n        setFft(generateEmptyFft());\n      }\n    };\n\n    frequencyDataIntervalId.current = window.setInterval(\n      updateFrequencyData,\n      5,\n    );\n\n    bufferSource.start(0);\n    onPlayAudio.current(nextClip.id);\n\n    bufferSource.onended = () => {\n      if (frequencyDataIntervalId.current) {\n        clearInterval(frequencyDataIntervalId.current);\n      }\n      setFft(generateEmptyFft());\n      bufferSource.disconnect();\n      isProcessing.current = false;\n      setIsPlaying(false);\n      onStopAudio.current(nextClip.id);\n      currentlyPlayingAudioBuffer.current = null;\n      playNextClip();\n    };\n  }, []);\n\n  const initPlayer = useCallback(() => {\n    const initAudioContext = new AudioContext();\n    audioContext.current = initAudioContext;\n\n    // Use AnalyserNode to get fft frequency data for visualizations\n    const analyser = initAudioContext.createAnalyser();\n    // Use GainNode to adjust volume\n    const gain = initAudioContext.createGain();\n\n    analyser.fftSize = 2048; // Must be a power of 2\n    analyser.connect(gain);\n    gain.connect(initAudioContext.destination);\n\n    analyserNode.current = analyser;\n    gainNode.current = gain;\n\n    isInitialized.current = true;\n  }, []);\n\n  const addToQueue = useCallback(\n    async (message: AudioOutputMessage) => {\n      if (!isInitialized.current || !audioContext.current) {\n        onError.current('Audio player has not been initialized');\n        return;\n      }\n\n      try {\n        const blob = convertBase64ToBlob(message.data, 'audio/mp3');\n        const arrayBuffer = await blob.arrayBuffer();\n        const audioBuffer =\n          await audioContext.current.decodeAudioData(arrayBuffer);\n\n        clipQueue.current.push({\n          id: message.id,\n          buffer: audioBuffer,\n        });\n        setQueueLength(clipQueue.current.length);\n\n        // playNextClip will iterate the clipQueue upon finishing the playback of the current audio clip, so we can\n        // just call playNextClip here if it's the only one in the queue\n        if (clipQueue.current.length === 1) {\n          playNextClip();\n        }\n      } catch (e) {\n        const eMessage = e instanceof Error ? e.message : 'Unknown error';\n        onError.current(`Failed to add clip to queue: ${eMessage}`);\n      }\n    },\n    [playNextClip],\n  );\n\n  const stopAll = useCallback(() => {\n    isInitialized.current = false;\n    isProcessing.current = false;\n    setIsPlaying(false);\n    setIsAudioMuted(false);\n\n    if (frequencyDataIntervalId.current) {\n      window.clearInterval(frequencyDataIntervalId.current);\n    }\n\n    if (currentlyPlayingAudioBuffer.current) {\n      currentlyPlayingAudioBuffer.current.disconnect();\n      currentlyPlayingAudioBuffer.current = null;\n    }\n\n    if (analyserNode.current) {\n      analyserNode.current.disconnect();\n      analyserNode.current = null;\n    }\n\n    if (audioContext.current) {\n      void audioContext.current\n        .close()\n        .then(() => {\n          audioContext.current = null;\n        })\n        .catch(() => {\n          // .close() rejects if the audio context is already closed.\n          // Therefore, we just need to catch the error, but we don't need to\n          // do anything with it.\n          return null;\n        });\n    }\n\n    clipQueue.current = [];\n    setQueueLength(0);\n    setFft(generateEmptyFft());\n  }, []);\n\n  const clearQueue = useCallback(() => {\n    if (currentlyPlayingAudioBuffer.current) {\n      currentlyPlayingAudioBuffer.current.stop();\n      currentlyPlayingAudioBuffer.current = null;\n    }\n\n    clipQueue.current = [];\n    setQueueLength(0);\n    isProcessing.current = false;\n    setIsPlaying(false);\n    setFft(generateEmptyFft());\n  }, []);\n\n  const muteAudio = useCallback(() => {\n    if (gainNode.current && audioContext.current) {\n      gainNode.current.gain.setValueAtTime(0, audioContext.current.currentTime);\n      setIsAudioMuted(true);\n    }\n  }, []);\n\n  const unmuteAudio = useCallback(() => {\n    if (gainNode.current && audioContext.current) {\n      gainNode.current.gain.setValueAtTime(1, audioContext.current.currentTime);\n      setIsAudioMuted(false);\n    }\n  }, []);\n\n  return {\n    addToQueue,\n    fft,\n    initPlayer,\n    isPlaying,\n    isAudioMuted,\n    muteAudio,\n    unmuteAudio,\n    stopAll,\n    clearQueue,\n    queueLength,\n  };\n};\n","// This function converts linear-scaled frequency decibels from an AnalyserNode's frequncy data to Bark scale [https://en.wikipedia.org/wiki/Bark_scale]\n// This implementation uses a simple approach of mapping indices in the linear-scaled array to the closest\n// Bark scale center frequency and is not intended to be an accurate representation, but rather \"close-enough\" for visualization purposes\nconst barkCenterFrequencies = [\n  50, 150, 250, 350, 450, 570, 700, 840, 1000, 1170, 1370, 1600, 1850, 2150,\n  2500, 2900, 3400, 4000, 4800, 5800, 7000, 8500, 10500, 13500,\n]; // Center frequency value in Hz\n\n// Min/max values from https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData\nconst minValue = 0;\nconst maxValue = 255;\n\nexport function convertLinearFrequenciesToBark(\n  linearData: Uint8Array,\n  sampleRate: number,\n): number[] {\n  const maxFrequency = sampleRate / 2;\n  const frequencyResolution = maxFrequency / linearData.length;\n\n  const barkFrequencies = barkCenterFrequencies.map((barkFreq) => {\n    const linearDataIndex = Math.round(barkFreq / frequencyResolution);\n    if (linearDataIndex >= 0 && linearDataIndex < linearData.length) {\n      return (\n        (((linearData[linearDataIndex] ?? 0) - minValue) /\n          (maxValue - minValue)) *\n        2\n      );\n    } else {\n      return 0;\n    }\n  });\n\n  return barkFrequencies;\n}\n","import { Hume, HumeClient } from 'hume';\nimport { useCallback, useRef, useState } from 'react';\nimport { type Simplify } from 'type-fest';\n\nimport { type AuthStrategy } from './auth';\nimport type {\n  AudioOutputMessage,\n  JSONMessage,\n  ToolCall,\n} from '../models/messages';\n\nconst isNever = (_n: never) => {\n  return;\n};\n\nexport type SocketConfig = {\n  auth: AuthStrategy;\n  hostname?: string;\n} & Hume.empathicVoice.chat.Chat.ConnectArgs;\n\nexport enum VoiceReadyState {\n  IDLE = 'idle',\n  CONNECTING = 'connecting',\n  OPEN = 'open',\n  CLOSED = 'closed',\n}\n\nexport type ToolCallHandler = (\n  // message will always be a tool call message where toolType === 'function'\n  message: Simplify<\n    ToolCall & {\n      // caveat: this doesn't actually do what it appears to, since ToolType is\n      // exported as both an interface and a value, this ends up being a constant\n      // that doesn't share an type identity with the actual ToolType enum\n      toolType: typeof Hume.empathicVoice.ToolType.Function;\n    }\n  >,\n  send: {\n    success: (content: unknown) => Hume.empathicVoice.ToolResponseMessage;\n    error: (e: {\n      error: string;\n      code: string;\n      level: string;\n      content: string;\n    }) => Hume.empathicVoice.ToolErrorMessage;\n  },\n) => Promise<\n  Hume.empathicVoice.ToolResponseMessage | Hume.empathicVoice.ToolErrorMessage\n>;\n\nexport const useVoiceClient = (props: {\n  onAudioMessage?: (message: AudioOutputMessage) => void;\n  onMessage?: (message: JSONMessage) => void;\n  onToolCall?: ToolCallHandler;\n  onError?: (message: string, error?: Error) => void;\n  onOpen?: () => void;\n  onClose?: Hume.empathicVoice.chat.ChatSocket.EventHandlers['close'];\n}) => {\n  const client = useRef<Hume.empathicVoice.chat.ChatSocket | null>(null);\n\n  const [readyState, setReadyState] = useState<VoiceReadyState>(\n    VoiceReadyState.IDLE,\n  );\n\n  // this pattern might look hacky but it allows us to use the latest props\n  // in callbacks set up inside useEffect without re-rendering the useEffect\n  const onAudioMessage = useRef<typeof props.onAudioMessage>(\n    props.onAudioMessage,\n  );\n  onAudioMessage.current = props.onAudioMessage;\n\n  const onMessage = useRef<typeof props.onMessage>(props.onMessage);\n  onMessage.current = props.onMessage;\n\n  const onToolCall = useRef<typeof props.onToolCall>(props.onToolCall);\n  onToolCall.current = props.onToolCall;\n\n  const onError = useRef<typeof props.onError>(props.onError);\n  onError.current = props.onError;\n\n  const onOpen = useRef<typeof props.onOpen>(props.onOpen);\n  onOpen.current = props.onOpen;\n\n  const onClose = useRef<typeof props.onClose>(props.onClose);\n  onClose.current = props.onClose;\n\n  const connect = useCallback((config: SocketConfig) => {\n    return new Promise((resolve, reject) => {\n      const hume = new HumeClient(\n        config.auth.type === 'apiKey'\n          ? {\n              apiKey: config.auth.value,\n              environment: config.hostname,\n            }\n          : {\n              accessToken: config.auth.value,\n              environment: config.hostname,\n            },\n      );\n\n      client.current = hume.empathicVoice.chat.connect(config);\n\n      client.current.on('open', () => {\n        onOpen.current?.();\n        setReadyState(VoiceReadyState.OPEN);\n        resolve(VoiceReadyState.OPEN);\n      });\n\n      client.current.on('message', (message) => {\n        if (message.type === 'audio_output') {\n          const messageWithReceivedAt = { ...message, receivedAt: new Date() };\n          onAudioMessage.current?.(messageWithReceivedAt);\n          return;\n        }\n\n        if (\n          message.type === 'assistant_message' ||\n          message.type === 'user_message' ||\n          message.type === 'user_interruption' ||\n          message.type === 'error' ||\n          message.type === 'tool_response' ||\n          message.type === 'tool_error' ||\n          message.type === 'chat_metadata' ||\n          message.type === 'assistant_end'\n        ) {\n          const messageWithReceivedAt = { ...message, receivedAt: new Date() };\n          onMessage.current?.(messageWithReceivedAt);\n          return;\n        }\n\n        if (message.type === 'tool_call') {\n          const messageWithReceivedAt = { ...message, receivedAt: new Date() };\n          onMessage.current?.(messageWithReceivedAt);\n\n          // only pass tool call messages for user defined tools\n          if (message.toolType === Hume.empathicVoice.ToolType.Function) {\n            void onToolCall\n              .current?.(\n                {\n                  ...messageWithReceivedAt,\n                  // we have to do this because even though we are using the correct\n                  // enum on line 30 for the type definition\n                  // fern exports an interface and a value using the same `ToolType`\n                  // identifier so the type comparisons will always fail\n                  toolType: 'function',\n                },\n                {\n                  success: (content: unknown) => ({\n                    type: 'tool_response',\n                    toolCallId: messageWithReceivedAt.toolCallId,\n                    content: JSON.stringify(content),\n                  }),\n                  error: ({\n                    error,\n                    code,\n                    level,\n                    content,\n                  }: {\n                    error: string;\n                    code: string;\n                    level: string;\n                    content: string;\n                  }) => ({\n                    type: 'tool_error',\n                    toolCallId: messageWithReceivedAt.toolCallId,\n                    error,\n                    code,\n                    level: level !== null ? 'warn' : undefined, // level can only be warn\n                    content,\n                  }),\n                },\n              )\n              .then((response) => {\n                // if valid send it to the socket\n                // otherwise, report error\n                if (response.type === 'tool_response') {\n                  client.current?.sendToolResponseMessage(response);\n                } else if (response.type === 'tool_error') {\n                  client.current?.sendToolErrorMessage(response);\n                } else {\n                  onError.current?.('Invalid response from tool call');\n                }\n              });\n          }\n          return;\n        }\n\n        // asserts that all message types are handled\n        isNever(message);\n        return;\n      });\n\n      client.current.on('close', (event) => {\n        onClose.current?.(event);\n        setReadyState(VoiceReadyState.CLOSED);\n      });\n\n      client.current.on('error', (e) => {\n        const message = e instanceof Error ? e.message : 'Unknown error';\n        onError.current?.(message, e instanceof Error ? e : undefined);\n        reject(e);\n      });\n\n      setReadyState(VoiceReadyState.CONNECTING);\n    });\n  }, []);\n\n  const disconnect = useCallback(() => {\n    setReadyState(VoiceReadyState.IDLE);\n    client.current?.close();\n  }, []);\n\n  const sendSessionSettings = useCallback(\n    (sessionSettings: Hume.empathicVoice.SessionSettings) => {\n      if (readyState !== VoiceReadyState.OPEN) {\n        throw new Error('Socket is not open');\n      }\n      client.current?.sendSessionSettings(sessionSettings);\n    },\n    [readyState],\n  );\n\n  const sendAudio = useCallback(\n    (arrayBuffer: ArrayBufferLike) => {\n      if (readyState !== VoiceReadyState.OPEN) {\n        throw new Error('Socket is not open');\n      }\n      client.current?.socket?.send(arrayBuffer);\n    },\n    [readyState],\n  );\n\n  const sendUserInput = useCallback(\n    (text: string) => {\n      if (readyState !== VoiceReadyState.OPEN) {\n        throw new Error('Socket is not open');\n      }\n      client.current?.sendUserInput(text);\n    },\n    [readyState],\n  );\n\n  const sendAssistantInput = useCallback(\n    (text: string) => {\n      if (readyState !== VoiceReadyState.OPEN) {\n        throw new Error('Socket is not open');\n      }\n      client.current?.sendAssistantInput({\n        text,\n      });\n    },\n    [readyState],\n  );\n\n  const sendToolMessage = useCallback(\n    (\n      // type definitions for toolMessage come from the Hume SDK because messages that are sent from the client\n      // to the backend do not have the extended `receivedAt` field\n      toolMessage:\n        | Hume.empathicVoice.ToolResponseMessage\n        | Hume.empathicVoice.ToolErrorMessage,\n    ) => {\n      if (readyState !== VoiceReadyState.OPEN) {\n        throw new Error('Socket is not open');\n      }\n      if (toolMessage.type === 'tool_error') {\n        client.current?.sendToolErrorMessage(toolMessage);\n      } else {\n        client.current?.sendToolResponseMessage(toolMessage);\n      }\n    },\n    [readyState],\n  );\n\n  const sendPauseAssistantMessage = useCallback(() => {\n    if (readyState !== VoiceReadyState.OPEN) {\n      throw new Error('Socket is not open');\n    }\n    client.current?.pauseAssistant({});\n  }, [readyState]);\n  const sendResumeAssistantMessage = useCallback(() => {\n    if (readyState !== VoiceReadyState.OPEN) {\n      throw new Error('Socket is not open');\n    }\n    client.current?.resumeAssistant({});\n  }, [readyState]);\n\n  return {\n    readyState,\n    sendSessionSettings,\n    sendAudio,\n    connect,\n    disconnect,\n    sendUserInput,\n    sendAssistantInput,\n    sendToolMessage,\n    sendPauseAssistantMessage,\n    sendResumeAssistantMessage,\n  };\n};\n","import { type Hume } from 'hume';\nimport React, {\n  createContext,\n  FC,\n  PropsWithChildren,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\n\nimport { ConnectionMessage } from './connection-message';\nimport { noop } from './noop';\nimport { useCallDuration } from './useCallDuration';\nimport { useEncoding } from './useEncoding';\nimport { useMessages } from './useMessages';\nimport { useMicrophone } from './useMicrophone';\nimport { useSoundPlayer } from './useSoundPlayer';\nimport { useToolStatus } from './useToolStatus';\nimport {\n  SocketConfig,\n  ToolCallHandler,\n  useVoiceClient,\n  VoiceReadyState,\n} from './useVoiceClient';\nimport {\n  AssistantTranscriptMessage,\n  AudioOutputMessage,\n  ChatMetadataMessage,\n  JSONMessage,\n  UserInterruptionMessage,\n  UserTranscriptMessage,\n} from '../models/messages';\n\ntype VoiceError =\n  | { type: 'socket_error'; message: string; error?: Error }\n  | { type: 'audio_error'; message: string; error?: Error }\n  | { type: 'mic_error'; message: string; error?: Error };\n\ntype VoiceStatus =\n  | {\n      value: 'disconnected' | 'connecting' | 'connected';\n      reason?: never;\n    }\n  | {\n      value: 'error';\n      reason: string;\n    };\n\nexport type VoiceContextType = {\n  connect: () => Promise<void>;\n  disconnect: () => void;\n  fft: number[];\n  isMuted: boolean;\n  isAudioMuted: boolean;\n  isPlaying: boolean;\n  messages: (JSONMessage | ConnectionMessage)[];\n  lastVoiceMessage: AssistantTranscriptMessage | null;\n  lastUserMessage: UserTranscriptMessage | null;\n  clearMessages: () => void;\n  mute: () => void;\n  unmute: () => void;\n  muteAudio: () => void;\n  unmuteAudio: () => void;\n  readyState: VoiceReadyState;\n  sendUserInput: (text: string) => void;\n  sendAssistantInput: (text: string) => void;\n  sendSessionSettings: Hume.empathicVoice.chat.ChatSocket['sendSessionSettings'];\n  sendToolMessage: (\n    type:\n      | Hume.empathicVoice.ToolResponseMessage\n      | Hume.empathicVoice.ToolErrorMessage,\n  ) => void;\n  pauseAssistant: () => void;\n  resumeAssistant: () => void;\n  status: VoiceStatus;\n  micFft: number[];\n  error: VoiceError | null;\n  isAudioError: boolean;\n  isError: boolean;\n  isMicrophoneError: boolean;\n  isSocketError: boolean;\n  callDurationTimestamp: string | null;\n  toolStatusStore: ReturnType<typeof useToolStatus>['store'];\n  chatMetadata: ChatMetadataMessage | null;\n  playerQueueLength: number;\n  isPaused: boolean;\n};\n\nconst VoiceContext = createContext<VoiceContextType | null>(null);\n\nexport type VoiceProviderProps = PropsWithChildren<SocketConfig> & {\n  sessionSettings?: Hume.empathicVoice.SessionSettings;\n  onMessage?: (message: JSONMessage) => void;\n  onError?: (err: VoiceError) => void;\n  onOpen?: () => void;\n  onClose?: Hume.empathicVoice.chat.ChatSocket.EventHandlers['close'];\n  onToolCall?: ToolCallHandler;\n  onAudioReceived?: (audioOutputMessage: AudioOutputMessage) => void;\n  onAudioStart?: (clipId: string) => void;\n  onAudioEnd?: (clipId: string) => void;\n  onInterruption?: (\n    message: UserTranscriptMessage | UserInterruptionMessage,\n  ) => void;\n  /**\n   * @default true\n   * @description Clear messages when the voice is disconnected.\n   */\n  clearMessagesOnDisconnect?: boolean;\n  /**\n   * @default 100\n   * @description The maximum number of messages to keep in memory.\n   */\n  messageHistoryLimit?: number;\n};\n\nexport const useVoice = () => {\n  const ctx = useContext(VoiceContext);\n  if (!ctx) {\n    throw new Error('useVoice must be used within an VoiceProvider');\n  }\n  return ctx;\n};\n\nexport const VoiceProvider: FC<VoiceProviderProps> = ({\n  children,\n  clearMessagesOnDisconnect = true,\n  messageHistoryLimit = 100,\n  sessionSettings,\n  verboseTranscription = true,\n  ...props\n}) => {\n  const {\n    timestamp: callDurationTimestamp,\n    start: startTimer,\n    stop: stopTimer,\n  } = useCallDuration();\n\n  const [status, setStatus] = useState<VoiceStatus>({\n    value: 'disconnected',\n  });\n\n  const [isPaused, setIsPaused] = useState(false);\n\n  // error handling\n  const [error, setError] = useState<VoiceError | null>(null);\n  const isError = error !== null;\n  const isMicrophoneError = error?.type === 'mic_error';\n  const isSocketError = error?.type === 'socket_error';\n  const isAudioError = error?.type === 'audio_error';\n\n  const onError = useRef(props.onError ?? noop);\n  onError.current = props.onError ?? noop;\n\n  const onClose = useRef(props.onClose ?? noop);\n  onClose.current = props.onClose ?? noop;\n\n  const onMessage = useRef(props.onMessage ?? noop);\n  onMessage.current = props.onMessage ?? noop;\n\n  const onAudioReceived = useRef(props.onAudioReceived ?? noop);\n  onAudioReceived.current = props.onAudioReceived ?? noop;\n\n  const onAudioStart = useRef(props.onAudioStart ?? noop);\n  onAudioStart.current = props.onAudioStart ?? noop;\n\n  const onAudioEnd = useRef(props.onAudioEnd ?? noop);\n  onAudioEnd.current = props.onAudioEnd ?? noop;\n\n  const onInterruption = useRef(props.onInterruption ?? noop);\n  onInterruption.current = props.onInterruption ?? noop;\n\n  const toolStatus = useToolStatus();\n\n  const messageStore = useMessages({\n    sendMessageToParent: onMessage.current,\n    messageHistoryLimit,\n  });\n\n  const updateError = useCallback((err: VoiceError | null) => {\n    setError(err);\n    if (err !== null) {\n      onError.current?.(err);\n    }\n  }, []);\n\n  const onClientError: NonNullable<\n    Parameters<typeof useVoiceClient>[0]['onError']\n  > = useCallback(\n    (message, err) => {\n      stopTimer();\n      updateError({ type: 'socket_error', message, error: err });\n    },\n    [stopTimer, updateError],\n  );\n\n  const config = props;\n\n  const player = useSoundPlayer({\n    onError: (message) => {\n      updateError({ type: 'audio_error', message });\n    },\n    onPlayAudio: (id: string) => {\n      messageStore.onPlayAudio(id);\n      onAudioStart.current(id);\n    },\n    onStopAudio: (id: string) => {\n      onAudioEnd.current(id);\n    },\n  });\n\n  const { streamRef, getStream, permission: micPermission } = useEncoding();\n\n  const client = useVoiceClient({\n    onAudioMessage: (message: AudioOutputMessage) => {\n      player.addToQueue(message);\n      onAudioReceived.current(message);\n    },\n    onMessage: useCallback(\n      (message: JSONMessage) => {\n        // store message\n        messageStore.onMessage(message);\n\n        if (\n          message.type === 'user_interruption' ||\n          message.type === 'user_message'\n        ) {\n          if (player.isPlaying) {\n            onInterruption.current(message);\n          }\n          player.clearQueue();\n        }\n\n        if (\n          message.type === 'tool_call' ||\n          message.type === 'tool_response' ||\n          message.type === 'tool_error'\n        ) {\n          toolStatus.addToStore(message);\n        }\n      },\n      [messageStore, player, toolStatus],\n    ),\n    onError: onClientError,\n    onOpen: useCallback(() => {\n      startTimer();\n      messageStore.createConnectMessage();\n      props.onOpen?.();\n    }, [messageStore, props, startTimer]),\n    onClose: useCallback<\n      NonNullable<Hume.empathicVoice.chat.ChatSocket.EventHandlers['close']>\n    >(\n      (event) => {\n        stopTimer();\n        messageStore.createDisconnectMessage(event);\n        onClose.current?.(event);\n      },\n      [messageStore, stopTimer],\n    ),\n    onToolCall: props.onToolCall,\n  });\n\n  const {\n    sendAudio: clientSendAudio,\n    sendUserInput: clientSendUserInput,\n    sendAssistantInput: clientSendAssistantInput,\n    sendSessionSettings: clientSendSessionSettings,\n    sendToolMessage: clientSendToolMessage,\n    sendPauseAssistantMessage,\n    sendResumeAssistantMessage,\n  } = client;\n\n  const mic = useMicrophone({\n    streamRef,\n    onAudioCaptured: useCallback(\n      (arrayBuffer) => {\n        try {\n          clientSendAudio(arrayBuffer);\n        } catch (e) {\n          const message = e instanceof Error ? e.message : 'Unknown error';\n          updateError({ type: 'socket_error', message });\n        }\n      },\n      [clientSendAudio, updateError],\n    ),\n    onError: useCallback(\n      (message) => {\n        updateError({ type: 'mic_error', message });\n      },\n      [updateError],\n    ),\n  });\n\n  const { clearQueue } = player;\n\n  const pauseAssistant = useCallback(() => {\n    try {\n      sendPauseAssistantMessage();\n      setIsPaused(true);\n    } catch (e) {\n      const message = e instanceof Error ? e.message : 'Unknown error';\n      updateError({ type: 'socket_error', message });\n    }\n    clearQueue();\n  }, [sendPauseAssistantMessage, clearQueue, updateError]);\n\n  const resumeAssistant = useCallback(() => {\n    try {\n      sendResumeAssistantMessage();\n      setIsPaused(false);\n    } catch (e) {\n      const message = e instanceof Error ? e.message : 'Unknown error';\n      updateError({ type: 'socket_error', message });\n    }\n  }, [sendResumeAssistantMessage, updateError]);\n\n  const connect = useCallback(async () => {\n    updateError(null);\n    setStatus({ value: 'connecting' });\n    const permission = await getStream();\n\n    if (permission === 'denied') {\n      const error: VoiceError = {\n        type: 'mic_error',\n        message: 'Microphone permission denied',\n      };\n      updateError(error);\n      return Promise.reject(error);\n    }\n\n    try {\n      await client.connect({\n        ...config,\n        verboseTranscription: true,\n      });\n    } catch (e) {\n      const error: VoiceError = {\n        type: 'socket_error',\n        message: 'We could not connect to the voice. Please try again.',\n      };\n      updateError(error);\n      return Promise.reject(error);\n    }\n\n    try {\n      const [micPromise, playerPromise] = await Promise.allSettled([\n        mic.start(),\n        player.initPlayer(),\n      ]);\n\n      if (\n        micPromise.status === 'fulfilled' &&\n        playerPromise.status === 'fulfilled'\n      ) {\n        setStatus({ value: 'connected' });\n      }\n    } catch (e) {\n      const error: VoiceError = {\n        type: 'audio_error',\n        message:\n          e instanceof Error\n            ? e.message\n            : 'We could not connect to audio. Please try again.',\n      };\n      updateError(error);\n    }\n  }, [client, config, getStream, mic, player, updateError]);\n\n  const disconnectFromVoice = useCallback(() => {\n    if (client.readyState !== VoiceReadyState.CLOSED) {\n      client.disconnect();\n    }\n    player.stopAll();\n    mic.stop();\n    if (clearMessagesOnDisconnect) {\n      messageStore.clearMessages();\n    }\n    toolStatus.clearStore();\n    setIsPaused(false);\n  }, [\n    client,\n    player,\n    mic,\n    clearMessagesOnDisconnect,\n    toolStatus,\n    messageStore,\n  ]);\n\n  const disconnect = useCallback(\n    (disconnectOnError?: boolean) => {\n      if (micPermission === 'denied') {\n        setStatus({ value: 'error', reason: 'Microphone permission denied' });\n      }\n\n      stopTimer();\n\n      disconnectFromVoice();\n\n      if (status.value !== 'error' && !disconnectOnError) {\n        // if status was 'error', keep the error status so we can show the error message to the end user.\n        // otherwise, set status to 'disconnected'\n        setStatus({ value: 'disconnected' });\n      }\n    },\n    [micPermission, stopTimer, disconnectFromVoice, status.value],\n  );\n\n  useEffect(() => {\n    if (\n      error !== null &&\n      status.value !== 'error' &&\n      status.value !== 'disconnected'\n    ) {\n      // If the status is ever set to `error`, disconnect the voice.\n      setStatus({ value: 'error', reason: error.message });\n      disconnectFromVoice();\n    }\n  }, [status.value, disconnect, disconnectFromVoice, error]);\n\n  useEffect(() => {\n    // disconnect from socket when the voice provider component unmounts\n    return () => {\n      disconnectFromVoice();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const sendUserInput = useCallback(\n    (text: string) => {\n      try {\n        clientSendUserInput(text);\n      } catch (e) {\n        const message = e instanceof Error ? e.message : 'Unknown error';\n        updateError({ type: 'socket_error', message });\n      }\n    },\n    [clientSendUserInput, updateError],\n  );\n\n  const sendAssistantInput = useCallback(\n    (text: string) => {\n      try {\n        clientSendAssistantInput(text);\n      } catch (e) {\n        const message = e instanceof Error ? e.message : 'Unknown error';\n        updateError({ type: 'socket_error', message });\n      }\n    },\n    [clientSendAssistantInput, updateError],\n  );\n\n  const sendSessionSettings = useCallback(\n    (sessionSettings: Hume.empathicVoice.SessionSettings) => {\n      try {\n        clientSendSessionSettings(sessionSettings);\n      } catch (e) {\n        const message = e instanceof Error ? e.message : 'Unknown error';\n        updateError({ type: 'socket_error', message });\n      }\n    },\n    [clientSendSessionSettings, updateError],\n  );\n\n  useEffect(() => {\n    if (\n      client.readyState === VoiceReadyState.OPEN &&\n      sessionSettings !== undefined &&\n      Object.keys(sessionSettings).length > 0\n    ) {\n      sendSessionSettings(sessionSettings);\n    }\n  }, [client.readyState, sendSessionSettings, sessionSettings]);\n\n  const sendToolMessage = useCallback(\n    (\n      message:\n        | Hume.empathicVoice.ToolResponseMessage\n        | Hume.empathicVoice.ToolErrorMessage,\n    ) => {\n      try {\n        clientSendToolMessage(message);\n      } catch (e) {\n        const message = e instanceof Error ? e.message : 'Unknown error';\n        updateError({ type: 'socket_error', message });\n      }\n    },\n    [clientSendToolMessage, updateError],\n  );\n\n  const ctx = useMemo(\n    () =>\n      ({\n        connect,\n        disconnect,\n        fft: player.fft,\n        micFft: mic.fft,\n        isMuted: mic.isMuted,\n        isAudioMuted: player.isAudioMuted,\n        isPlaying: player.isPlaying,\n        messages: messageStore.messages,\n        lastVoiceMessage: messageStore.lastVoiceMessage,\n        lastUserMessage: messageStore.lastUserMessage,\n        clearMessages: messageStore.clearMessages,\n        mute: mic.mute,\n        muteAudio: player.muteAudio,\n        readyState: client.readyState,\n        sendUserInput,\n        sendAssistantInput,\n        sendSessionSettings,\n        pauseAssistant,\n        resumeAssistant,\n        sendToolMessage,\n        status,\n        unmute: mic.unmute,\n        unmuteAudio: player.unmuteAudio,\n        error,\n        isAudioError,\n        isError,\n        isMicrophoneError,\n        isSocketError,\n        callDurationTimestamp,\n        toolStatusStore: toolStatus.store,\n        chatMetadata: messageStore.chatMetadata,\n        playerQueueLength: player.queueLength,\n        isPaused,\n      }) satisfies VoiceContextType,\n    [\n      connect,\n      disconnect,\n      player.fft,\n      player.isAudioMuted,\n      player.isPlaying,\n      player.muteAudio,\n      player.unmuteAudio,\n      player.queueLength,\n      mic.fft,\n      mic.isMuted,\n      mic.mute,\n      mic.unmute,\n      messageStore.messages,\n      messageStore.lastVoiceMessage,\n      messageStore.lastUserMessage,\n      messageStore.clearMessages,\n      messageStore.chatMetadata,\n      client.readyState,\n      sendUserInput,\n      sendAssistantInput,\n      sendSessionSettings,\n      pauseAssistant,\n      resumeAssistant,\n      sendToolMessage,\n      status,\n      error,\n      isAudioError,\n      isError,\n      isMicrophoneError,\n      isSocketError,\n      callDurationTimestamp,\n      toolStatus.store,\n      isPaused,\n    ],\n  );\n\n  return <VoiceContext.Provider value={ctx}>{children}</VoiceContext.Provider>;\n};\n","export const noop = () => {};\n","import { intervalToDuration } from 'date-fns';\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nexport const useCallDuration = () => {\n  const interval = useRef<number | null>(null);\n  const startTime = useRef<number | null>(null);\n\n  const [timestamp, setTimestamp] = useState<string | null>(null);\n\n  const start = useCallback(() => {\n    startTime.current = Date.now();\n\n    setTimestamp('00:00:00');\n\n    interval.current = window.setInterval(() => {\n      if (startTime.current) {\n        const duration = intervalToDuration({\n          start: startTime.current,\n          end: Date.now(),\n        });\n\n        const hours = (duration.hours ?? 0).toString().padStart(2, '0');\n        const minutes = (duration.minutes ?? 0).toString().padStart(2, '0');\n        const seconds = (duration.seconds ?? 0).toString().padStart(2, '0');\n\n        setTimestamp(`${hours}:${minutes}:${seconds}`);\n      }\n    }, 500);\n  }, []);\n\n  const stop = useCallback(() => {\n    if (interval.current) {\n      window.clearInterval(interval.current);\n      interval.current = null;\n    }\n  }, []);\n\n  const reset = useCallback(() => {\n    setTimestamp(null);\n  }, []);\n\n  useEffect(() => {\n    // clean up on unmount\n    return () => {\n      if (interval.current) {\n        window.clearInterval(interval.current);\n        interval.current = null;\n      }\n    };\n  }, []);\n\n  return { timestamp, start, stop, reset };\n};\n","// cspell:ignore dataavailable\nimport { checkForAudioTracks, getAudioStream } from 'hume';\nimport { useCallback, useRef, useState } from 'react';\n\ntype PermissionStatus = 'prompt' | 'granted' | 'denied';\n\nconst useEncoding = () => {\n  const [permission, setPermission] = useState<PermissionStatus>('prompt');\n\n  const streamRef = useRef<MediaStream | null>(null);\n\n  const getStream = useCallback(async () => {\n    try {\n      const stream = await getAudioStream();\n\n      setPermission('granted');\n      streamRef.current = stream;\n\n      checkForAudioTracks(stream);\n\n      return 'granted' as const;\n    } catch (e) {\n      setPermission('denied');\n      return 'denied' as const;\n    }\n  }, []);\n\n  return {\n    streamRef,\n    getStream,\n    permission,\n  };\n};\n\nexport { useEncoding };\n","import type { CloseEvent } from 'hume/core';\nimport { useCallback, useState } from 'react';\n\nimport type { ConnectionMessage } from './connection-message';\nimport type {\n  AssistantTranscriptMessage,\n  ChatMetadataMessage,\n  JSONMessage,\n  UserTranscriptMessage,\n} from '../models/messages';\nimport { keepLastN } from '../utils';\n\nexport const useMessages = ({\n  sendMessageToParent,\n  messageHistoryLimit,\n}: {\n  sendMessageToParent?: (message: JSONMessage) => void;\n  messageHistoryLimit: number;\n}) => {\n  const [voiceMessageMap, setVoiceMessageMap] = useState<\n    Record<string, AssistantTranscriptMessage>\n  >({});\n\n  const [messages, setMessages] = useState<\n    Array<JSONMessage | ConnectionMessage>\n  >([]);\n\n  const [lastVoiceMessage, setLastVoiceMessage] =\n    useState<AssistantTranscriptMessage | null>(null);\n  const [lastUserMessage, setLastUserMessage] =\n    useState<UserTranscriptMessage | null>(null);\n\n  const [chatMetadata, setChatMetadata] = useState<ChatMetadataMessage | null>(\n    null,\n  );\n\n  const createConnectMessage = useCallback(() => {\n    setMessages((prev) =>\n      prev.concat([\n        {\n          type: 'socket_connected',\n          receivedAt: new Date(),\n        },\n      ]),\n    );\n  }, []);\n\n  const createDisconnectMessage = useCallback((event: CloseEvent) => {\n    setMessages((prev) =>\n      prev.concat([\n        {\n          type: 'socket_disconnected',\n          code: event.code,\n          reason: event.reason,\n          receivedAt: new Date(),\n        },\n      ]),\n    );\n  }, []);\n\n  const onMessage = useCallback(\n    (message: JSONMessage) => {\n      /* \n      1. message comes in from the backend\n        - if the message IS NOT AssistantTranscriptMessage, store in `messages` immediately  \n        - if the message is an AssistantTranscriptMessage, stored in `voiceMessageMap`\n      2. audio clip plays\n        - find the AssistantTranscriptMessage with a matching ID, and store it in `messages`\n        - remove the AssistantTranscriptMessage from `voiceMessageMap`\n    */\n      switch (message.type) {\n        case 'assistant_message':\n          // for assistant messages, `sendMessageToParent` is called in `onPlayAudio`\n          // in order to line up the transcript event with the correct audio clip\n          setVoiceMessageMap((prev) => ({\n            ...prev,\n            [`${message.id}`]: message,\n          }));\n          break;\n        case 'user_message':\n          sendMessageToParent?.(message);\n\n          // Exclude interim messages from the messages array.\n          // If end users want to see interim messages, they can use the onMessage\n          // callback because we are still sending them via `sendMessageToParent`.\n          if (message.interim === false) {\n            setLastUserMessage(message);\n            setMessages((prev) => {\n              return keepLastN(messageHistoryLimit, prev.concat([message]));\n            });\n          }\n\n          break;\n        case 'user_interruption':\n        case 'error':\n        case 'tool_call':\n        case 'tool_response':\n        case 'tool_error':\n        case 'assistant_end':\n          sendMessageToParent?.(message);\n          setMessages((prev) => {\n            return keepLastN(messageHistoryLimit, prev.concat([message]));\n          });\n          break;\n        case 'chat_metadata':\n          sendMessageToParent?.(message);\n          setMessages((prev) => {\n            return keepLastN(messageHistoryLimit, prev.concat([message]));\n          });\n          setChatMetadata(message);\n          break;\n        default:\n          break;\n      }\n    },\n    [messageHistoryLimit, sendMessageToParent],\n  );\n\n  const onPlayAudio = useCallback(\n    (id: string) => {\n      const matchingTranscript = voiceMessageMap[id];\n      if (matchingTranscript) {\n        sendMessageToParent?.(matchingTranscript);\n        setLastVoiceMessage(matchingTranscript);\n        setMessages((prev) => {\n          return keepLastN(\n            messageHistoryLimit,\n            prev.concat([matchingTranscript]),\n          );\n        });\n        // remove the message from the map to ensure we don't\n        // accidentally push it to the messages array more than once\n        setVoiceMessageMap((prev) => {\n          const newMap = { ...prev };\n          delete newMap[id];\n          return newMap;\n        });\n      }\n    },\n    [voiceMessageMap, sendMessageToParent, messageHistoryLimit],\n  );\n\n  const clearMessages = useCallback(() => {\n    setMessages([]);\n    setLastVoiceMessage(null);\n    setLastUserMessage(null);\n    setVoiceMessageMap({});\n  }, []);\n\n  return {\n    createConnectMessage,\n    createDisconnectMessage,\n    onMessage,\n    onPlayAudio,\n    clearMessages,\n    messages,\n    lastVoiceMessage,\n    lastUserMessage,\n    chatMetadata,\n  };\n};\n","export const keepLastN = <T>(n: number, arr: T[]): T[] => {\n  if (arr.length <= n) {\n    return arr;\n  }\n  return arr.slice(arr.length - n);\n};\n","import { useCallback, useState } from 'react';\n\nimport type { ToolCall, ToolError, ToolResponse } from '../models/messages';\n\nexport const useToolStatus = () => {\n  const [store, setStore] = useState<\n    Record<\n      string,\n      {\n        call?: ToolCall;\n        resolved?: ToolResponse | ToolError;\n      }\n    >\n  >({});\n\n  const addToStore = useCallback(\n    (message: ToolCall | ToolResponse | ToolError) => {\n      setStore((prev) => {\n        const entry = {\n          ...prev[message.toolCallId],\n        };\n\n        if (message.type === 'tool_call') {\n          entry.call = message;\n        }\n\n        if (message.type === 'tool_response' || message.type === 'tool_error') {\n          entry.resolved = message;\n        }\n\n        return {\n          ...prev,\n          [message.toolCallId]: entry,\n        };\n      });\n    },\n    [],\n  );\n\n  const clearStore = useCallback(() => {\n    setStore({});\n  }, []);\n\n  return {\n    store,\n    addToStore,\n    clearStore,\n  };\n};\n","export class SocketUnknownMessageError extends Error {\n  constructor(message?: string) {\n    super(`Unknown message type.${message ? ' ' + message : ''}`);\n    this.name = 'SocketUnknownMessageError';\n  }\n}\n\n/**\n * @name isSocketUnknownMessageError\n * @description\n * Check if an error is a SocketUnknownMessageError.\n * @param err - The error to check.\n * @returns\n * `true` if the error is a SocketUnknownMessageError.\n * @example\n * ```ts\n * if (isSocketUnknownMessageError(err)) {\n * console.error('Unknown message type');\n * }\n * ```\n */\nexport const isSocketUnknownMessageError = (\n  err: unknown,\n): err is SocketUnknownMessageError => {\n  return err instanceof SocketUnknownMessageError;\n};\n\nexport class SocketFailedToParseMessageError extends Error {\n  constructor(message?: string) {\n    super(\n      `Failed to parse message from socket.${message ? ' ' + message : ''}`,\n    );\n    this.name = 'SocketFailedToParseMessageError';\n  }\n}\n\n/**\n * @name isSocketFailedToParseMessageError\n * @description\n * Check if an error is a SocketFailedToParseMessageError.\n * @param err - The error to check.\n * @returns\n * `true` if the error is a SocketFailedToParseMessageError.\n * @example\n * ```ts\n * if (isSocketFailedToParseMessageError(err)) {\n * console.error('Failed to parse message from socket');\n * }\n * ```\n */\nexport const isSocketFailedToParseMessageError = (\n  err: unknown,\n): err is SocketFailedToParseMessageError => {\n  return err instanceof SocketFailedToParseMessageError;\n};\n","import { type Hume } from 'hume';\nimport { SubscribeEvent } from 'hume/serialization/resources/empathicVoice/index.js';\n\nimport { type AudioMessage, parseAudioMessage } from './audio-message';\nimport {\n  SocketFailedToParseMessageError,\n  SocketUnknownMessageError,\n} from './errors';\n\n/**\n * @name parseMessageData\n * @description\n * Parse the data of a message from the socket.\n * @param data - The data to parse.\n * @returns\n * The parsed message data.\n * @example\n * ```ts\n * const message = await parseMessageData(data);\n * ```\n */\nexport const parseMessageData = async (\n  data: unknown,\n): Promise<\n  | {\n      success: true;\n      message: Hume.empathicVoice.SubscribeEvent | AudioMessage;\n    }\n  | {\n      success: false;\n      error: Error;\n    }\n> => {\n  if (data instanceof Blob) {\n    const message = await parseAudioMessage(data);\n\n    if (message) {\n      return {\n        success: true,\n        message,\n      };\n    } else {\n      return {\n        success: false,\n        error: new SocketFailedToParseMessageError(\n          `Received blob was unable to be converted to ArrayBuffer.`,\n        ),\n      };\n    }\n  }\n\n  if (typeof data !== 'string') {\n    return {\n      success: false,\n      error: new SocketFailedToParseMessageError(\n        `Expected a string but received ${typeof data}.`,\n      ),\n    };\n  }\n\n  const parseResponse = SubscribeEvent.parse(data);\n\n  if (!parseResponse.ok) {\n    return {\n      success: false,\n      error: new SocketUnknownMessageError(\n        `Received JSON was not a known message type.`,\n      ),\n    };\n  }\n\n  return {\n    success: true,\n    message: parseResponse.value,\n  };\n};\n\n/**\n * @name parseMessageType\n * @description\n * Parse the type of a message from the socket.\n * @param event - The event to parse.\n * @returns\n * The parsed message type.\n * @example\n * ```ts\n * const message = await parseMessageType(event);\n * ```\n */\nexport const parseMessageType = async (\n  event: MessageEvent,\n): Promise<\n  | {\n      success: true;\n      message: Hume.empathicVoice.SubscribeEvent | AudioMessage;\n    }\n  | {\n      success: false;\n      error: Error;\n    }\n> => {\n  const data: unknown = event.data;\n  return parseMessageData(data);\n};\n","import z from 'zod';\n\nexport const AudioMessageSchema = z\n  .object({\n    type: z.literal('audio'),\n    data: z.instanceof(ArrayBuffer),\n  })\n  .transform((obj) => {\n    return Object.assign(obj, {\n      receivedAt: new Date(),\n    });\n  });\n\nexport type AudioMessage = z.infer<typeof AudioMessageSchema>;\n\nexport const parseAudioMessage = async (\n  blob: Blob,\n): Promise<AudioMessage | null> => {\n  return blob\n    .arrayBuffer()\n    .then((buffer) => {\n      return {\n        type: 'audio' as const,\n        data: buffer,\n        receivedAt: new Date(),\n      };\n    })\n    .catch(() => {\n      return null;\n    });\n};\n","export enum Channels {\n  /** Mono */\n  MONO = 1,\n  /** Stereo */\n  STEREO = 2,\n}\n\nexport enum AudioEncoding {\n  /** 16-bit signed little-endian (PCM) */\n  LINEAR16 = 'linear16',\n  /** Ogg Opus */\n  OPUS = 'opus',\n}\n","export enum LanguageModelOption {\n  CLAUDE_3_OPUS = 'CLAUDE_3_OPUS',\n  CLAUDE_3_SONNET = 'CLAUDE_3_SONNET',\n  CLAUDE_3_HAIKU = 'CLAUDE_3_HAIKU',\n  CLAUDE_21 = 'CLAUDE_21',\n  CLAUDE_INSTANT_12 = 'CLAUDE_INSTANT_12',\n  GPT_4_TURBO_PREVIEW = 'GPT_4_TURBO_PREVIEW',\n  GPT_35_TURBO_0125 = 'GPT_35_TURBO_0125',\n  GPT_35_TURBO = 'GPT_35_TURBO',\n  FIREWORKS_MIXTRAL_8X7B = 'FIREWORKS_MIXTRAL_8X7B',\n}\n","import type {\n  AssistantEnd,\n  AssistantMessage,\n  AudioInput,\n  AudioOutput,\n  ChatMetadata,\n  JsonMessage,\n  ToolCallMessage,\n  ToolErrorMessage,\n  ToolResponseMessage,\n  UserInterruption,\n  UserMessage,\n  WebSocketError,\n} from 'hume/api/resources/empathicVoice';\nimport z from 'zod';\n\ntype WithReceivedAt<T> = T & { receivedAt: Date };\n\nexport type AssistantEndMessage = WithReceivedAt<AssistantEnd>;\nexport type AssistantTranscriptMessage = WithReceivedAt<AssistantMessage>;\nexport type AudioMessage = WithReceivedAt<AudioInput>;\nexport type AudioOutputMessage = WithReceivedAt<AudioOutput>;\nexport type ChatMetadataMessage = WithReceivedAt<ChatMetadata>;\nexport type JSONErrorMessage = WithReceivedAt<WebSocketError>;\nexport type JSONMessage = WithReceivedAt<JsonMessage>;\nexport type ToolCall = WithReceivedAt<ToolCallMessage>;\nexport type ToolError = WithReceivedAt<ToolErrorMessage>;\nexport type ToolResponse = WithReceivedAt<ToolResponseMessage>;\nexport type UserInterruptionMessage = WithReceivedAt<UserInterruption>;\nexport type UserTranscriptMessage = WithReceivedAt<UserMessage>;\n\nexport const TimeSliceSchema = z.object({\n  begin: z.number(),\n  end: z.number(),\n});\n\nexport type TimeSlice = z.infer<typeof TimeSliceSchema>;\n","export enum TTSService {\n  /** Hume's Text-To-Speech */\n  DEFAULT = 'hume_ai',\n  /** ElevenLab's Text-To-Speech */\n  ELEVEN_LABS = 'eleven_labs',\n  /** Play HT's Text-To-Speech */\n  PLAY_HT = 'play_ht',\n}\n"],"mappings":"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","names":["Meyda","import_hume","import_react","import_hume","import_react","VoiceReadyState","import_react","import_react","import_hume","import_react","import_react","import_react","error","sessionSettings","message","z","Channels","AudioEncoding","LanguageModelOption","import_zod","z","TTSService"]}