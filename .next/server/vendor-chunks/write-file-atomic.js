"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/write-file-atomic";
exports.ids = ["vendor-chunks/write-file-atomic"];
exports.modules = {

/***/ "(ssr)/./node_modules/write-file-atomic/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/write-file-atomic/lib/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = writeFile\nmodule.exports.sync = writeFileSync\nmodule.exports._getTmpname = getTmpname // for testing\nmodule.exports._cleanupOnExit = cleanupOnExit\n\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst MurmurHash3 = __webpack_require__(/*! imurmurhash */ \"(ssr)/./node_modules/imurmurhash/imurmurhash.js\")\nconst { onExit } = __webpack_require__(/*! signal-exit */ \"(ssr)/./node_modules/signal-exit/dist/cjs/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst { promisify } = __webpack_require__(/*! util */ \"util\")\nconst activeFiles = {}\n\n// if we run inside of a worker_thread, `process.pid` is not unique\n/* istanbul ignore next */\nconst threadId = (function getId () {\n  try {\n    const workerThreads = __webpack_require__(/*! worker_threads */ \"worker_threads\")\n\n    /// if we are in main thread, this is set to `0`\n    return workerThreads.threadId\n  } catch (e) {\n    // worker_threads are not available, fallback to 0\n    return 0\n  }\n})()\n\nlet invocations = 0\nfunction getTmpname (filename) {\n  return filename + '.' +\n    MurmurHash3(__filename)\n      .hash(String(process.pid))\n      .hash(String(threadId))\n      .hash(String(++invocations))\n      .result()\n}\n\nfunction cleanupOnExit (tmpfile) {\n  return () => {\n    try {\n      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile)\n    } catch {\n      // ignore errors\n    }\n  }\n}\n\nfunction serializeActiveFile (absoluteName) {\n  return new Promise(resolve => {\n    // make a queue if it doesn't already exist\n    if (!activeFiles[absoluteName]) {\n      activeFiles[absoluteName] = []\n    }\n\n    activeFiles[absoluteName].push(resolve) // add this job to the queue\n    if (activeFiles[absoluteName].length === 1) {\n      resolve()\n    } // kick off the first one\n  })\n}\n\n// https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342\nfunction isChownErrOk (err) {\n  if (err.code === 'ENOSYS') {\n    return true\n  }\n\n  const nonroot = !process.getuid || process.getuid() !== 0\n  if (nonroot) {\n    if (err.code === 'EINVAL' || err.code === 'EPERM') {\n      return true\n    }\n  }\n\n  return false\n}\n\nasync function writeFileAsync (filename, data, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  let fd\n  let tmpfile\n  /* istanbul ignore next -- The closure only gets called when onExit triggers */\n  const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile))\n  const absoluteName = path.resolve(filename)\n\n  try {\n    await serializeActiveFile(absoluteName)\n    const truename = await promisify(fs.realpath)(filename).catch(() => filename)\n    tmpfile = getTmpname(truename)\n\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      const stats = await promisify(fs.stat)(truename).catch(() => {})\n      if (stats) {\n        if (options.mode == null) {\n          options.mode = stats.mode\n        }\n\n        if (options.chown == null && process.getuid) {\n          options.chown = { uid: stats.uid, gid: stats.gid }\n        }\n      }\n    }\n\n    fd = await promisify(fs.open)(tmpfile, 'w', options.mode)\n    if (options.tmpfileCreated) {\n      await options.tmpfileCreated(tmpfile)\n    }\n    if (ArrayBuffer.isView(data)) {\n      await promisify(fs.write)(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      await promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n\n    if (options.fsync !== false) {\n      await promisify(fs.fsync)(fd)\n    }\n\n    await promisify(fs.close)(fd)\n    fd = null\n\n    if (options.chown) {\n      await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      })\n    }\n\n    if (options.mode) {\n      await promisify(fs.chmod)(tmpfile, options.mode).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      })\n    }\n\n    await promisify(fs.rename)(tmpfile, truename)\n  } finally {\n    if (fd) {\n      await promisify(fs.close)(fd).catch(\n        /* istanbul ignore next */\n        () => {}\n      )\n    }\n    removeOnExitHandler()\n    await promisify(fs.unlink)(tmpfile).catch(() => {})\n    activeFiles[absoluteName].shift() // remove the element added by serializeSameFile\n    if (activeFiles[absoluteName].length > 0) {\n      activeFiles[absoluteName][0]() // start next job if one is pending\n    } else {\n      delete activeFiles[absoluteName]\n    }\n  }\n}\n\nasync function writeFile (filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options\n    options = {}\n  }\n\n  const promise = writeFileAsync(filename, data, options)\n  if (callback) {\n    try {\n      const result = await promise\n      return callback(result)\n    } catch (err) {\n      return callback(err)\n    }\n  }\n\n  return promise\n}\n\nfunction writeFileSync (filename, data, options) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  } else if (!options) {\n    options = {}\n  }\n  try {\n    filename = fs.realpathSync(filename)\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  const tmpfile = getTmpname(filename)\n\n  if (!options.mode || !options.chown) {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    try {\n      const stats = fs.statSync(filename)\n      options = Object.assign({}, options)\n      if (!options.mode) {\n        options.mode = stats.mode\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = { uid: stats.uid, gid: stats.gid }\n      }\n    } catch (ex) {\n      // ignore stat errors\n    }\n  }\n\n  let fd\n  const cleanup = cleanupOnExit(tmpfile)\n  const removeOnExitHandler = onExit(cleanup)\n\n  let threw = true\n  try {\n    fd = fs.openSync(tmpfile, 'w', options.mode || 0o666)\n    if (options.tmpfileCreated) {\n      options.tmpfileCreated(tmpfile)\n    }\n    if (ArrayBuffer.isView(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n    if (options.fsync !== false) {\n      fs.fsyncSync(fd)\n    }\n\n    fs.closeSync(fd)\n    fd = null\n\n    if (options.chown) {\n      try {\n        fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      }\n    }\n\n    if (options.mode) {\n      try {\n        fs.chmodSync(tmpfile, options.mode)\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      }\n    }\n\n    fs.renameSync(tmpfile, filename)\n    threw = false\n  } finally {\n    if (fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (ex) {\n        // ignore close errors at this stage, error may have closed fd already.\n      }\n    }\n    removeOnExitHandler()\n    if (threw) {\n      cleanup()\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3JpdGUtZmlsZS1hdG9taWMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQSxtQkFBbUI7QUFDbkIsMEJBQTBCO0FBQzFCLDZCQUE2Qjs7QUFFN0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsb0VBQWE7QUFDekMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx1RUFBYTtBQUN4QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLHNDQUFnQjs7QUFFbEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UcmFucXVpbG8vLi9ub2RlX21vZHVsZXMvd3JpdGUtZmlsZS1hdG9taWMvbGliL2luZGV4LmpzPzJmOWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHdyaXRlRmlsZVxubW9kdWxlLmV4cG9ydHMuc3luYyA9IHdyaXRlRmlsZVN5bmNcbm1vZHVsZS5leHBvcnRzLl9nZXRUbXBuYW1lID0gZ2V0VG1wbmFtZSAvLyBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMuX2NsZWFudXBPbkV4aXQgPSBjbGVhbnVwT25FeGl0XG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgTXVybXVySGFzaDMgPSByZXF1aXJlKCdpbXVybXVyaGFzaCcpXG5jb25zdCB7IG9uRXhpdCB9ID0gcmVxdWlyZSgnc2lnbmFsLWV4aXQnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgYWN0aXZlRmlsZXMgPSB7fVxuXG4vLyBpZiB3ZSBydW4gaW5zaWRlIG9mIGEgd29ya2VyX3RocmVhZCwgYHByb2Nlc3MucGlkYCBpcyBub3QgdW5pcXVlXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdGhyZWFkSWQgPSAoZnVuY3Rpb24gZ2V0SWQgKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHdvcmtlclRocmVhZHMgPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpXG5cbiAgICAvLy8gaWYgd2UgYXJlIGluIG1haW4gdGhyZWFkLCB0aGlzIGlzIHNldCB0byBgMGBcbiAgICByZXR1cm4gd29ya2VyVGhyZWFkcy50aHJlYWRJZFxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gd29ya2VyX3RocmVhZHMgYXJlIG5vdCBhdmFpbGFibGUsIGZhbGxiYWNrIHRvIDBcbiAgICByZXR1cm4gMFxuICB9XG59KSgpXG5cbmxldCBpbnZvY2F0aW9ucyA9IDBcbmZ1bmN0aW9uIGdldFRtcG5hbWUgKGZpbGVuYW1lKSB7XG4gIHJldHVybiBmaWxlbmFtZSArICcuJyArXG4gICAgTXVybXVySGFzaDMoX19maWxlbmFtZSlcbiAgICAgIC5oYXNoKFN0cmluZyhwcm9jZXNzLnBpZCkpXG4gICAgICAuaGFzaChTdHJpbmcodGhyZWFkSWQpKVxuICAgICAgLmhhc2goU3RyaW5nKCsraW52b2NhdGlvbnMpKVxuICAgICAgLnJlc3VsdCgpXG59XG5cbmZ1bmN0aW9uIGNsZWFudXBPbkV4aXQgKHRtcGZpbGUpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMudW5saW5rU3luYyh0eXBlb2YgdG1wZmlsZSA9PT0gJ2Z1bmN0aW9uJyA/IHRtcGZpbGUoKSA6IHRtcGZpbGUpXG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBpZ25vcmUgZXJyb3JzXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFjdGl2ZUZpbGUgKGFic29sdXRlTmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgLy8gbWFrZSBhIHF1ZXVlIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgIGlmICghYWN0aXZlRmlsZXNbYWJzb2x1dGVOYW1lXSkge1xuICAgICAgYWN0aXZlRmlsZXNbYWJzb2x1dGVOYW1lXSA9IFtdXG4gICAgfVxuXG4gICAgYWN0aXZlRmlsZXNbYWJzb2x1dGVOYW1lXS5wdXNoKHJlc29sdmUpIC8vIGFkZCB0aGlzIGpvYiB0byB0aGUgcXVldWVcbiAgICBpZiAoYWN0aXZlRmlsZXNbYWJzb2x1dGVOYW1lXS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJlc29sdmUoKVxuICAgIH0gLy8ga2ljayBvZmYgdGhlIGZpcnN0IG9uZVxuICB9KVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ3JhY2VmdWwtZnMvYmxvYi9tYXN0ZXIvcG9seWZpbGxzLmpzI0wzMTUtTDM0MlxuZnVuY3Rpb24gaXNDaG93bkVyck9rIChlcnIpIHtcbiAgaWYgKGVyci5jb2RlID09PSAnRU5PU1lTJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBub25yb290ID0gIXByb2Nlc3MuZ2V0dWlkIHx8IHByb2Nlc3MuZ2V0dWlkKCkgIT09IDBcbiAgaWYgKG5vbnJvb3QpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFSU5WQUwnIHx8IGVyci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUZpbGVBc3luYyAoZmlsZW5hbWUsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9XG5cbiAgbGV0IGZkXG4gIGxldCB0bXBmaWxlXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0tIFRoZSBjbG9zdXJlIG9ubHkgZ2V0cyBjYWxsZWQgd2hlbiBvbkV4aXQgdHJpZ2dlcnMgKi9cbiAgY29uc3QgcmVtb3ZlT25FeGl0SGFuZGxlciA9IG9uRXhpdChjbGVhbnVwT25FeGl0KCgpID0+IHRtcGZpbGUpKVxuICBjb25zdCBhYnNvbHV0ZU5hbWUgPSBwYXRoLnJlc29sdmUoZmlsZW5hbWUpXG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBzZXJpYWxpemVBY3RpdmVGaWxlKGFic29sdXRlTmFtZSlcbiAgICBjb25zdCB0cnVlbmFtZSA9IGF3YWl0IHByb21pc2lmeShmcy5yZWFscGF0aCkoZmlsZW5hbWUpLmNhdGNoKCgpID0+IGZpbGVuYW1lKVxuICAgIHRtcGZpbGUgPSBnZXRUbXBuYW1lKHRydWVuYW1lKVxuXG4gICAgaWYgKCFvcHRpb25zLm1vZGUgfHwgIW9wdGlvbnMuY2hvd24pIHtcbiAgICAgIC8vIEVpdGhlciBtb2RlIG9yIGNob3duIGlzIG5vdCBleHBsaWNpdGx5IHNldFxuICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byBjb3B5IGl0IGZyb20gb3JpZ2luYWwgZmlsZVxuICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBwcm9taXNpZnkoZnMuc3RhdCkodHJ1ZW5hbWUpLmNhdGNoKCgpID0+IHt9KVxuICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMubW9kZSA9IHN0YXRzLm1vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmNob3duID09IG51bGwgJiYgcHJvY2Vzcy5nZXR1aWQpIHtcbiAgICAgICAgICBvcHRpb25zLmNob3duID0geyB1aWQ6IHN0YXRzLnVpZCwgZ2lkOiBzdGF0cy5naWQgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmQgPSBhd2FpdCBwcm9taXNpZnkoZnMub3BlbikodG1wZmlsZSwgJ3cnLCBvcHRpb25zLm1vZGUpXG4gICAgaWYgKG9wdGlvbnMudG1wZmlsZUNyZWF0ZWQpIHtcbiAgICAgIGF3YWl0IG9wdGlvbnMudG1wZmlsZUNyZWF0ZWQodG1wZmlsZSlcbiAgICB9XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgYXdhaXQgcHJvbWlzaWZ5KGZzLndyaXRlKShmZCwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDApXG4gICAgfSBlbHNlIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgIGF3YWl0IHByb21pc2lmeShmcy53cml0ZSkoZmQsIFN0cmluZyhkYXRhKSwgMCwgU3RyaW5nKG9wdGlvbnMuZW5jb2RpbmcgfHwgJ3V0ZjgnKSlcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mc3luYyAhPT0gZmFsc2UpIHtcbiAgICAgIGF3YWl0IHByb21pc2lmeShmcy5mc3luYykoZmQpXG4gICAgfVxuXG4gICAgYXdhaXQgcHJvbWlzaWZ5KGZzLmNsb3NlKShmZClcbiAgICBmZCA9IG51bGxcblxuICAgIGlmIChvcHRpb25zLmNob3duKSB7XG4gICAgICBhd2FpdCBwcm9taXNpZnkoZnMuY2hvd24pKHRtcGZpbGUsIG9wdGlvbnMuY2hvd24udWlkLCBvcHRpb25zLmNob3duLmdpZCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKCFpc0Nob3duRXJyT2soZXJyKSkge1xuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1vZGUpIHtcbiAgICAgIGF3YWl0IHByb21pc2lmeShmcy5jaG1vZCkodG1wZmlsZSwgb3B0aW9ucy5tb2RlKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAoIWlzQ2hvd25FcnJPayhlcnIpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgYXdhaXQgcHJvbWlzaWZ5KGZzLnJlbmFtZSkodG1wZmlsZSwgdHJ1ZW5hbWUpXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKGZkKSB7XG4gICAgICBhd2FpdCBwcm9taXNpZnkoZnMuY2xvc2UpKGZkKS5jYXRjaChcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgKCkgPT4ge31cbiAgICAgIClcbiAgICB9XG4gICAgcmVtb3ZlT25FeGl0SGFuZGxlcigpXG4gICAgYXdhaXQgcHJvbWlzaWZ5KGZzLnVubGluaykodG1wZmlsZSkuY2F0Y2goKCkgPT4ge30pXG4gICAgYWN0aXZlRmlsZXNbYWJzb2x1dGVOYW1lXS5zaGlmdCgpIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBhZGRlZCBieSBzZXJpYWxpemVTYW1lRmlsZVxuICAgIGlmIChhY3RpdmVGaWxlc1thYnNvbHV0ZU5hbWVdLmxlbmd0aCA+IDApIHtcbiAgICAgIGFjdGl2ZUZpbGVzW2Fic29sdXRlTmFtZV1bMF0oKSAvLyBzdGFydCBuZXh0IGpvYiBpZiBvbmUgaXMgcGVuZGluZ1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgYWN0aXZlRmlsZXNbYWJzb2x1dGVOYW1lXVxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUZpbGUgKGZpbGVuYW1lLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gd3JpdGVGaWxlQXN5bmMoZmlsZW5hbWUsIGRhdGEsIG9wdGlvbnMpXG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlXG4gICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiB3cml0ZUZpbGVTeW5jIChmaWxlbmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9IGVsc2UgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cbiAgdHJ5IHtcbiAgICBmaWxlbmFtZSA9IGZzLnJlYWxwYXRoU3luYyhmaWxlbmFtZSlcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICAvLyBpdCdzIG9rLCBpdCdsbCBoYXBwZW4gb24gYSBub3QgeWV0IGV4aXN0aW5nIGZpbGVcbiAgfVxuICBjb25zdCB0bXBmaWxlID0gZ2V0VG1wbmFtZShmaWxlbmFtZSlcblxuICBpZiAoIW9wdGlvbnMubW9kZSB8fCAhb3B0aW9ucy5jaG93bikge1xuICAgIC8vIEVpdGhlciBtb2RlIG9yIGNob3duIGlzIG5vdCBleHBsaWNpdGx5IHNldFxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gY29weSBpdCBmcm9tIG9yaWdpbmFsIGZpbGVcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhmaWxlbmFtZSlcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKVxuICAgICAgaWYgKCFvcHRpb25zLm1vZGUpIHtcbiAgICAgICAgb3B0aW9ucy5tb2RlID0gc3RhdHMubW9kZVxuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLmNob3duICYmIHByb2Nlc3MuZ2V0dWlkKSB7XG4gICAgICAgIG9wdGlvbnMuY2hvd24gPSB7IHVpZDogc3RhdHMudWlkLCBnaWQ6IHN0YXRzLmdpZCB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIC8vIGlnbm9yZSBzdGF0IGVycm9yc1xuICAgIH1cbiAgfVxuXG4gIGxldCBmZFxuICBjb25zdCBjbGVhbnVwID0gY2xlYW51cE9uRXhpdCh0bXBmaWxlKVxuICBjb25zdCByZW1vdmVPbkV4aXRIYW5kbGVyID0gb25FeGl0KGNsZWFudXApXG5cbiAgbGV0IHRocmV3ID0gdHJ1ZVxuICB0cnkge1xuICAgIGZkID0gZnMub3BlblN5bmModG1wZmlsZSwgJ3cnLCBvcHRpb25zLm1vZGUgfHwgMG82NjYpXG4gICAgaWYgKG9wdGlvbnMudG1wZmlsZUNyZWF0ZWQpIHtcbiAgICAgIG9wdGlvbnMudG1wZmlsZUNyZWF0ZWQodG1wZmlsZSlcbiAgICB9XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgZnMud3JpdGVTeW5jKGZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMClcbiAgICB9IGVsc2UgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgZnMud3JpdGVTeW5jKGZkLCBTdHJpbmcoZGF0YSksIDAsIFN0cmluZyhvcHRpb25zLmVuY29kaW5nIHx8ICd1dGY4JykpXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZzeW5jICE9PSBmYWxzZSkge1xuICAgICAgZnMuZnN5bmNTeW5jKGZkKVxuICAgIH1cblxuICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICBmZCA9IG51bGxcblxuICAgIGlmIChvcHRpb25zLmNob3duKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jaG93blN5bmModG1wZmlsZSwgb3B0aW9ucy5jaG93bi51aWQsIG9wdGlvbnMuY2hvd24uZ2lkKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghaXNDaG93bkVyck9rKGVycikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLmNobW9kU3luYyh0bXBmaWxlLCBvcHRpb25zLm1vZGUpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFpc0Nob3duRXJyT2soZXJyKSkge1xuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnMucmVuYW1lU3luYyh0bXBmaWxlLCBmaWxlbmFtZSlcbiAgICB0aHJldyA9IGZhbHNlXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKGZkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAvLyBpZ25vcmUgY2xvc2UgZXJyb3JzIGF0IHRoaXMgc3RhZ2UsIGVycm9yIG1heSBoYXZlIGNsb3NlZCBmZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVPbkV4aXRIYW5kbGVyKClcbiAgICBpZiAodGhyZXcpIHtcbiAgICAgIGNsZWFudXAoKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/write-file-atomic/lib/index.js\n");

/***/ })

};
;